/*
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2009, Willow Garage, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of Willow Garage, Inc. nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include <opencv2/cnn_3dobj.hpp>
#include <iomanip>
using namespace cv;
using namespace std;
using namespace cv::cnn_3dobj;
int main(int argc, char** argv)
{
	const String keys = "{help | | this demo will convert a set of images in a particular path into leveldb database for feature extraction using Caffe.}"
		     "{src_dir | ../data/images_all/ | Source direction of the images ready for being converted to leveldb dataset.}"
		     "{src_dst | ../data/dbfile | Aim direction of the converted to leveldb dataset. }"
		     "{attach_dir | ../data/dbfile | Path for saving additional files which describe the transmission results. }"
		     "{channel | 1 | Channel of the images. }"
		     "{width | 64 | Width of images}"
		     "{height | 64 | Height of images}"
		     "{caffemodel | ../data/3d_triplet_iter_10000.caffemodel | caffe model for feature exrtaction.}"
		     "{network_forDB | ../data/3d_triplet_galleryIMG.prototxt | Network definition file used for extracting feature from levelDB data, causion: the path of levelDB training samples must be wrotten in in .prototxt files in Phase TEST}"
		     "{save_feature_dataset_names | ../data/feature/feature_iter_10000.bin | Output of the extracted feature in form of binary files together with the vector<cv::Mat> features as the feature.}"
		     "{extract_feature_blob_names | feat | Layer used for feature extraction in CNN.}"
		     "{num_mini_batches | 4 | Batches suit for the batches defined in the .proto for the aim of extracting feature from all images.}"
		     "{device | CPU | Device: CPU or GPU.}"
		     "{dev_id | 0 | ID of GPU.}"
		     "{network_forIMG | ../data/3d_triplet_testIMG.prototxt | Network definition file used for extracting feature from a single image and making a classification}"
		     "{mean_file | ../data/images_mean/triplet_mean.binaryproto | The mean file generated by Caffe from all gallery images, this could be used for mean value substraction from all images.}"
		     "{label_file | ../data/dbfileimage_filename | A namelist including all gallery images.}"
		     "{target_img | ../data/images_all/2_13.png | Path of image waiting to be classified.}"
		     "{num_candidate | 6 | Number of candidates in gallery as the prediction result.}";
	cv::CommandLineParser parser(argc, argv, keys);
	parser.about("Demo for Sphere View data generation");
	if (parser.has("help"))
	{
		parser.printMessage();
		return 0;
	}
	string src_dir = parser.get<string>("src_dir");
	string src_dst = parser.get<string>("src_dst");
	string attach_dir = parser.get<string>("attach_dir");
	int channel = parser.get<int>("channel");
	int width = parser.get<int>("width");
	int height = parser.get<int>("height");
	string caffemodel = parser.get<string>("caffemodel");
	string network_forDB = parser.get<string>("network_forDB");
	string save_feature_dataset_names = parser.get<string>("save_feature_dataset_names");
	string extract_feature_blob_names = parser.get<string>("extract_feature_blob_names");
	int num_mini_batches = parser.get<int>("num_mini_batches");
	string device = parser.get<string>("device");
	int dev_id = parser.get<int>("dev_id");
	string network_forIMG   = parser.get<string>("network_forIMG");
	string mean_file    = parser.get<string>("mean_file");
	string label_file   = parser.get<string>("label_file");
	string target_img   = parser.get<string>("target_img");
	int num_candidate = parser.get<int>("num_candidate");
	cv::cnn_3dobj::DataTrans transTemp;
	transTemp.convert(src_dir,src_dst,attach_dir,channel,width,height);
	std::vector<cv::Mat> feature_reference = transTemp.feature_extraction_pipeline(caffemodel, network_forDB, save_feature_dataset_names, extract_feature_blob_names, num_mini_batches, device, dev_id);
////start another demo
	cv::cnn_3dobj::Classification classifier(network_forIMG, caffemodel, mean_file, label_file);

	std::cout << std::endl << "---------- Prediction for "
	    << target_img << " ----------" << std::endl;

	cv::Mat img = cv::imread(target_img, -1);
	// CHECK(!img.empty()) << "Unable to decode image " << target_img;
	std::cout << std::endl << "---------- Featrue of gallery images ----------" << std::endl;
	std::vector<std::pair<string, float> > prediction;
	for (unsigned int i = 0; i < feature_reference.size(); i++)
		std::cout << feature_reference[i] << endl;
	cv::Mat feature_test = classifier.feature_extract(img, false);
	std::cout << std::endl << "---------- Featrue of target image: " << target_img << "----------" << endl << feature_test.t() << std::endl;
	prediction = classifier.Classify(feature_reference, img, num_candidate, false);
	// Print the top N prediction.
	std::cout << std::endl << "---------- Prediction result(distance - file name in gallery) ----------" << std::endl;
	for (size_t i = 0; i < prediction.size(); ++i) {
	std::pair<string, float> p = prediction[i];
	std::cout << std::fixed << std::setprecision(2) << p.second << " - \""
	      << p.first << "\"" << std::endl;
	}
	return 0;
}
